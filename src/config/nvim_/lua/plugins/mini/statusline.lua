if not mines or not mines.ui.statusline.enable then return end

mines.ui.statusline = {}

return {
  'echasnovski/mini.statusline',
  lazy = false,
  enabled = false,
  config = function()
    vim.opt.laststatus = 3 -- global statusline
    local MiniStatusline = require 'mini.statusline'

    local function myMode()
      local util = require 'lib.lualine'
      local mode = util.mode_names[vim.fn.mode(1)] -- :h mode()

      if util.mode_names[vim.fn.mode(1)] ~= 'normal' then return util.modes[mode].label end

      return ''
    end

    MiniStatusline.setup {
      active = function()
        local mode, mode_hl = MiniStatusline.section_mode { trunc_width = 120 }
        local git = MiniStatusline.section_git { trunc_width = 75 }
        local diagnostics = MiniStatusline.section_diagnostics { trunc_width = 75 }
        local filename = MiniStatusline.section_filename { trunc_width = 140 }
        local fileinfo = MiniStatusline.section_fileinfo { trunc_width = 120 }
        local location = MiniStatusline.section_location { trunc_width = 75 }

        return require('mini.statusline').combine_groups {
          { hl = mode_hl, strings = { mode } },
          -- { hl = 'MiniStatuslineDevinfo', strings = { git, diagnostics } },
          '%<', -- Mark general truncate point
          { hl = 'MiniStatuslineFilename', strings = { require('lib.lualine').filepath_mod() } },
          '%=', -- End left alignment
          { hl = 'MiniStatuslineFileinfo', strings = { fileinfo } },
          { hl = mode_hl, strings = { location } },
        }
      end,
      set_vim_settings = false,
    }
  end,

  -- config = function()
  --   ----------------------------------------------------------------------------------------------------
  --   --  Types
  --   ----------------------------------------------------------------------------------------------------
  --
  --   ---@class StatuslineContext
  --   ---@field bufnum number
  --   ---@field win number
  --   ---@field bufname string
  --   ---@field preview boolean
  --   ---@field readonly boolean
  --   ---@field filetype string
  --   ---@field buftype string
  --   ---@field modified boolean
  --   ---@field fileformat string
  --   ---@field shiftwidth number
  --   ---@field expandtab boolean
  --   ---@field winhl boolean
  --
  --   ----------------------------------------------------------------------------------------------------
  --
  --   local icons, lsp, highlight, decorations = mines.ui.icons, mines.ui.lsp, mines.highlight, mines.ui.decorations
  --   local api, fn, fs, fmt, strwidth = vim.api, vim.fn, vim.fs, string.format, vim.api.nvim_strwidth
  --   local P, falsy = mines.ui.palette, mines.falsy
  --
  --   local sep = package.config:sub(1, 1)
  --   local space = ' '
  --
  --   ----------------------------------------------------------------------------------------------------
  --   --  Colors
  --   ----------------------------------------------------------------------------------------------------
  --   local hls = {
  --     statusline = 'StatusLine',
  --     statusline_nc = 'StatusLineNC',
  --     metadata = 'StMetadata',
  --     metadata_prefix = 'StMetadataPrefix',
  --     indicator = 'StIndicator',
  --     modified = 'StModified',
  --     git = 'StGit',
  --     green = 'StGreen',
  --     blue = 'StBlue',
  --     number = 'StNumber',
  --     count = 'StCount',
  --     client = 'StClient',
  --     env = 'StEnv',
  --     directory = 'StDirectory',
  --     directory_inactive = 'StDirectoryInactive',
  --     parent_directory = 'StParentDirectory',
  --     title = 'StTitle',
  --     comment = 'StComment',
  --     info = 'StInfo',
  --     warn = 'StWarn',
  --     error = 'StError',
  --     filename = 'StFilename',
  --     filename_inactive = 'StFilenameInactive',
  --     mode_normal = 'StModeNormal',
  --     mode_insert = 'StModeInsert',
  --     mode_visual = 'StModeVisual',
  --     mode_replace = 'StModeReplace',
  --     mode_command = 'StModeCommand',
  --     mode_select = 'StModeSelect',
  --     hydra_red = 'HydraRedSt',
  --     hydra_blue = 'HydraBlueSt',
  --     hydra_amaranth = 'HydraAmaranthSt',
  --     hydra_teal = 'HydraTealSt',
  --     hydra_pink = 'HydraPinkSt',
  --   }
  --
  --   local function colors()
  --     --- NOTE: Unicode characters including vim devicons should NOT be highlighted
  --     --- as italic or bold, this is because the underlying bold font is not necessarily
  --     --- patched with the nerd font characters
  --     --- terminal emulators like kitty handle this by fetching nerd fonts elsewhere
  --     --- but this is not universal across terminals so should be avoided
  --
  --     local indicator_color = P.bright_blue
  --     local warning_fg = lsp.colors.warn
  --
  --     local error_color = lsp.colors.error
  --     local info_color = lsp.colors.info
  --     local normal_fg = highlight.get('Normal', 'fg')
  --     local string_fg = highlight.get('String', 'fg')
  --     local number_fg = highlight.get('Number', 'fg')
  --     local normal_bg = highlight.get('Normal', 'bg')
  --
  --     local bg_color = highlight.tint(normal_bg, -0.25)
  --
  --     -- stylua: ignore
  --     highlight.all({
  --       { [hls.metadata] = { bg = bg_color, inherit = 'Comment' } },
  --       { [hls.metadata_prefix] = { bg = bg_color, fg = { from = 'Comment' } } },
  --       { [hls.indicator] = { bg = bg_color, fg = indicator_color } },
  --       { [hls.modified] = { fg = string_fg, bg = bg_color } },
  --       { [hls.git] = { fg = P.light_gray, bg = bg_color } },
  --       { [hls.green] = { fg = string_fg, bg = bg_color } },
  --       { [hls.blue] = { fg = P.dark_blue, bg = bg_color, bold = true } },
  --       { [hls.number] = { fg = number_fg, bg = bg_color } },
  --       { [hls.count] = { fg = 'bg', bg = indicator_color, bold = true } },
  --       { [hls.client] = { bg = bg_color, fg = normal_fg, bold = true } },
  --       { [hls.env] = { bg = bg_color, fg = error_color, italic = true, bold = true } },
  --       { [hls.directory] = { bg = bg_color, fg = 'Gray', italic = true } },
  --       { [hls.directory_inactive] = { bg = bg_color, italic = true, fg = { from = 'Normal', alter = 0.4 } } },
  --       { [hls.parent_directory] = { bg = bg_color, fg = string_fg, bold = true } },
  --       { [hls.title] = { bg = bg_color, fg = 'LightGray', bold = true } },
  --       { [hls.comment] = { bg = bg_color, inherit = 'Comment' } },
  --       { [hls.statusline] = { bg = bg_color } },
  --       { [hls.statusline_nc] = { link = 'VertSplit' } },
  --       { [hls.info] = { fg = info_color, bg = bg_color, bold = true } },
  --       { [hls.warn] = { fg = warning_fg, bg = bg_color } },
  --       { [hls.error] = { fg = error_color, bg = bg_color } },
  --       { [hls.filename] = { bg = bg_color, fg = 'LightGray', bold = true } },
  --       { [hls.filename_inactive] = { inherit = 'Comment', bg = bg_color, bold = true } },
  --       { [hls.mode_normal] = { bg = bg_color, fg = P.light_gray, bold = true } },
  --       { [hls.mode_insert] = { bg = bg_color, fg = P.dark_blue, bold = true } },
  --       { [hls.mode_visual] = { bg = bg_color, fg = P.magenta, bold = true } },
  --       { [hls.mode_replace] = { bg = bg_color, fg = P.dark_red, bold = true } },
  --       { [hls.mode_command] = { bg = bg_color, fg = P.light_yellow, bold = true } },
  --       { [hls.mode_select] = { bg = bg_color, fg = P.teal, bold = true } },
  --       { [hls.hydra_red] = { inherit = 'HydraRed', reverse = true } },
  --       { [hls.hydra_blue] = { inherit = 'HydraBlue', reverse = true } },
  --       { [hls.hydra_amaranth] = { inherit = 'HydraAmaranth', reverse = true } },
  --       { [hls.hydra_teal] = { inherit = 'HydraTeal', reverse = true } },
  --       { [hls.hydra_pink] = { inherit = 'HydraPink', reverse = true } },
  --     })
  --   end
  --
  --   colors()
  --
  --   local identifiers = {
  --     buftypes = {
  --       terminal = ' ',
  --       quickfix = '',
  --     },
  --     filetypes = mines.p_table {
  --       ['fzf'] = '',
  --       ['log'] = '',
  --       ['org'] = '',
  --       ['orgagenda'] = '',
  --       ['himalaya-msg-list'] = '',
  --       ['mail'] = '',
  --       ['dbui'] = '',
  --       ['DiffviewFiles'] = 'פּ',
  --       ['tsplayground'] = '侮',
  --       ['Trouble'] = '',
  --       ['NeogitStatus'] = '', -- '',
  --       ['norg'] = 'ﴬ',
  --       ['help'] = '',
  --       ['octo'] = '',
  --       ['minimap'] = '',
  --       ['undotree'] = 'פּ',
  --       ['NvimTree'] = 'פּ',
  --       ['neo-tree'] = 'פּ',
  --       ['neotest.*'] = 'פּ',
  --       ['dapui_.*'] = '',
  --       ['dap-repl'] = '',
  --       ['toggleterm'] = ' ',
  --     },
  --     names = mines.p_table {
  --       ['fzf'] = 'FZF',
  --       ['orgagenda'] = 'Org',
  --       ['himalaya-msg-list'] = 'Inbox',
  --       ['mail'] = 'Mail',
  --       ['minimap'] = '',
  --       ['dbui'] = 'Dadbod UI',
  --       ['tsplayground'] = 'Treesitter',
  --       ['NeogitStatus'] = 'Neogit Status',
  --       ['Neogit.*'] = 'Neogit',
  --       ['Trouble'] = 'Lsp Trouble',
  --       ['gitcommit'] = 'Git commit',
  --       ['help'] = 'help',
  --       ['undotree'] = 'UndoTree',
  --       ['octo'] = 'Octo',
  --       ['NvimTree'] = 'Nvim Tree',
  --       ['dap-repl'] = 'Debugger REPL',
  --       ['Diffview.*'] = 'Diff view',
  --       ['neotest.*'] = 'Testing',
  --
  --       ['log'] = function(fname, _) return fmt('Log(%s)', fs.basename(fname)) end,
  --
  --       ['dapui_.*'] = function(fname) return fname end,
  --
  --       ['neo-tree'] = function(fname, _)
  --         local parts = vim.split(fname, ' ')
  --         return fmt('Neo Tree(%s)', parts[2])
  --       end,
  --
  --       ['toggleterm'] = function(_, buf)
  --         local shell = fn.fnamemodify(vim.env.SHELL, ':t')
  --         return fmt('Terminal(%s)[%s]', shell, api.nvim_buf_get_var(buf, 'toggle_number'))
  --       end,
  --     },
  --   }
  --   -- We don't load LuaSnip until InsertEnter, so we don't check for it until it could possibly be loaded.
  --   local luasnip_might_have_loaded = false
  --
  --   mines.augroup('StatuslineCheckInsert', {
  --     event = 'InsertEnter',
  --     command = function() luasnip_might_have_loaded = true end,
  --     once = true,
  --   })
  --
  --   ---Only append the path separator if the path is not empty
  --   ---@param path string
  --   ---@return string
  --   local function path_sep(path) return not mines.falsy(path) and path .. sep or path end
  --
  --   local H = {}
  --
  --   ----------------------------------------------------------------------------------------------------
  --
  --   --  Utility functions
  --   ----------------------------------------------------------------------------------------------------
  --
  --   --- @param ctx StatuslineContext
  --   local function is_plain(ctx)
  --     local decor = mines.ui.decorations.get { ft = ctx.filetype, bt = ctx.buftype, setting = 'statusline' }
  --     local is_plain_ft, is_plain_bt = decor.ft == 'minimal', decor.bt == 'minimal'
  --     return is_plain_ft or is_plain_bt or ctx.preview
  --   end
  --
  --   --- @param ctx StatuslineContext
  --   --- @param icon string | nil
  --   local function is_modified(ctx, icon) return ctx.filetype == 'help' and '' or ctx.modified and (icon or '✎') or '' end
  --
  --   local curwin = vim.api.nvim_get_current_win()
  --   local curbuf = vim.api.nvim_win_get_buf(curwin)
  --
  --   local ctx = {
  --     bufnum = curbuf,
  --     win = curwin,
  --     bufname = vim.api.nvim_buf_get_name(curbuf),
  --     preview = vim.wo[curwin].previewwindow,
  --     readonly = vim.bo[curbuf].readonly,
  --     filetype = vim.bo[curbuf].ft,
  --     buftype = vim.bo[curbuf].bt,
  --     modified = vim.bo[curbuf].modified,
  --     fileformat = vim.bo[curbuf].fileformat,
  --     shiftwidth = vim.bo[curbuf].shiftwidth,
  --     expandtab = vim.bo[curbuf].expandtab,
  --   }
  --
  --   ----------------------------------------------------------------------------//
  --   -- Modifiers
  --   ----------------------------------------------------------------------------//
  --
  --   local plain = is_plain(ctx)
  --   local file_modified = is_modified(ctx, mines.ui.icons.misc.circle)
  --   local focused = vim.g.vim_in_focus or true
  --
  --   --- This function allow me to specify titles for special case buffers
  --   --- like the preview window or a quickfix window
  --   --- CREDIT: https://vi.stackexchange.com/a/18090
  --   -- @param ctx StatuslineContext
  --   local function special_buffers(ctx)
  --     local location_list = vim.fn.getloclist(0, { filewinid = 0 })
  --     local is_loc_list = location_list.filewinid > 0
  --     local normal_term = ctx.buftype == 'terminal' and ctx.filetype == ''
  --
  --     if is_loc_list then return 'Location List' end
  --     if ctx.buftype == 'quickfix' then return 'Quickfix List' end
  --     if normal_term then return 'Terminal(' .. vim.fn.fnamemodify(vim.env.SHELL, ':t') .. ')' end
  --     if ctx.preview then return 'preview' end
  --
  --     return nil
  --   end
  --
  --   ---Only append the path separator if the path is not empty
  --   ---@param path string
  --   ---@return string
  --   local function with_sep(path) return (not mines.falsy(path) and path:sub(-1) ~= sep) and path .. sep or path end
  --   local SYNC_DIR = vim.fn.resolve(vim.env.SYNC_DIR)
  --
  --   --- Replace the directory path with an identifier if it matches a commonly visited
  --   --- directory of mine such as my projects directory or my work directory
  --   --- since almost all my project directories are nested underneath one of these paths
  --   --- this should match often and reduce the unnecessary boilerplate in my path as
  --   --- I know where these directories are generally
  --   ---@param directory string
  --   ---@return string directory
  --   ---@return string custom_dir
  --   local function dir_env(directory)
  --     if not directory then return '', '' end
  --     local paths = {
  --       [vim.g.dotfiles] = '$DOTFILES',
  --       [vim.env.HOME] = '~',
  --       -- [vim.g.work_dir] = '$WORK',
  --       [vim.g.projects_dir] = '$PROJECTS',
  --       [vim.env.VIMRUNTIME] = '$VIMRUNTIME',
  --       [SYNC_DIR] = '$SYNC',
  --     }
  --     local result, env, prev_match = directory, '', ''
  --     for dir, alias in pairs(paths) do
  --       local match, count = vim.fs.normalize(directory):gsub(vim.pesc(with_sep(dir)), '')
  --       if count == 1 and #dir > #prev_match then
  --         result, env, prev_match = match, alias, dir
  --       end
  --     end
  --     return result, env
  --   end
  --
  --   local function filename(args)
  --     local buf, ft = ctx.bufnum, ctx.filetype
  --     local special_buf = special_buffers(ctx)
  --     if special_buf then return special_buf end
  --
  --     local path = vim.api.nvim_buf_get_name(buf)
  --     if mines.falsy(path) then return 'No Name' end
  --
  --     --- add ":." to the expansion i.e. to make the directory path relative to the current vim directory
  --     local parts = vim.split(vim.fn.fnamemodify(path, ':~'), sep)
  --     local fname = table.remove(parts)
  --
  --     local name = identifiers.names[ft]
  --     if name then return vim.is_callable(name) and name(fname, buf) or name end
  --
  --     local parent = table.remove(parts)
  --     fname = vim.fn.isdirectory(fname) == 1 and fname .. sep or fname
  --     if mines.falsy(parent) then return { fname = fname } end
  --
  --     local dir = with_sep(table.concat(parts, sep))
  --     local new_dir, env = dir_env(dir)
  --     local segment = not mines.falsy(env) and env .. new_dir or dir
  --     if vim.fn.strwidth(segment) > math.floor(vim.o.columns / 3) then new_dir = vim.fn.pathshorten(new_dir) end
  --
  --     return { env = with_sep(env), dir = with_sep(new_dir), parent = with_sep(parent), fname = fname }
  --   end
  --
  --   local function stl_file(ctx, minimal)
  --     -- highlight the filename components separately
  --     local filename_hl = 'StFilename'
  --     local directory_hl = 'StDirectory'
  --     local parent_hl = 'StParentDirectory'
  --     local env_hl = 'StEnv'
  --
  --     local file_opts = { before = '', after = ' ', priority = 0 }
  --     local parent_opts = { before = '', after = '', priority = 2 }
  --     local dir_opts = { before = '', after = '', priority = 3 }
  --     local env_opts = { before = '', after = '', priority = 4 }
  --
  --     local p = filename(ctx)
  --
  --     return {
  --       env = { item = p.env, hl = env_hl, opts = env_opts },
  --       file = { item = p.fname, hl = filename_hl, opts = file_opts },
  --       dir = { item = p.dir, hl = directory_hl, opts = dir_opts },
  --       parent = { item = p.parent, hl = parent_hl, opts = parent_opts },
  --     }
  --   end
  --
  --   function H.hl(group, output) return string.format('%%#%s#%s%%*', group, output) end
  --
  --   function H.is_disabled() return vim.g.ministatusline_disable == true or vim.b.ministatusline_disable == true end
  --
  --   function H.get_config(config)
  --     return vim.tbl_deep_extend(
  --       'force',
  --       require('mini.statusline').config,
  --       vim.b.ministatusline_config or {},
  --       config or {}
  --     )
  --   end
  --
  --   H.diagnostic_levels = nil
  --
  --   function H.isnt_normal_buffer()
  --     -- For more information see ":h buftype"
  --     return vim.bo.buftype ~= ''
  --   end
  --
  --   function H.get_filesize()
  --     local bytes = vim.fn.eval 'getfsize(expand(@%))'
  --     local sizes = { 'B', 'KB', 'MB', 'GB' }
  --     local i = 1
  --     while bytes >= 1024.0 do
  --       bytes = bytes / 1024.0
  --       i = i + 1
  --     end
  --     if bytes > 0 then
  --       return vim.fn.printf('%.1f%s', bytes, sizes[i]) .. ''
  --     else
  --       return ''
  --     end
  --   end
  --
  --   function H.get_filetype_icon()
  --     -- Skip if NerdFonts is disabled
  --     if not H.get_config().use_icons then return '' end
  --     -- Have this `require()` here to not depend on plugin initialization order
  --     local has_devicons, devicons = pcall(require, 'nvim-web-devicons')
  --     if not has_devicons then return '' end
  --
  --     local file_name, file_ext = vim.fn.expand '%:t', vim.fn.expand '%:e'
  --     return devicons.get_icon(file_name, file_ext, { default = true })
  --   end
  --
  --   function H.get_diagnostic_count(id) return #vim.diagnostic.get(0, { severity = id }) end
  --
  --   local M = {}
  --
  --   M.section_icon = function(args)
  --     if require('mini.statusline').is_truncated(args.trunc_width) then return '' end
  --     local icon = H.get_filetype_icon()
  --     if vim.bo.buftype == 'help' then icon = '' end
  --     if vim.bo.buftype == 'terminal' then icon = '' end
  --     if vim.bo.buftype == 'quickfix' then icon = '' end
  --     if vim.bo.buftype == 'org' then icon = '' end
  --     if vim.bo.buftype == 'orgagenda' then icon = '' end
  --     if vim.bo.buftype == 'himalaya-msg-list' then icon = '' end
  --     if vim.bo.buftype == 'mail' then icon = '' end
  --     if vim.bo.buftype == 'dbui' then icon = '' end
  --     if vim.bo.buftype == 'DiffviewFiles' then icon = 'פּ' end
  --     if vim.bo.buftype == 'tsplayground' then icon = '侮' end
  --     if vim.bo.buftype == 'Trouble' then icon = '' end
  --     if vim.bo.buftype == 'NeogitStatus' then icon = '' end
  --     if vim.bo.buftype == 'norg' then icon = 'ﴬ' end
  --     if vim.bo.buftype == 'help' then icon = '' end
  --     if vim.bo.buftype == 'undotree' then icon = 'פּ' end
  --     if vim.bo.buftype == 'NvimTree' then icon = 'פּ' end
  --     if vim.bo.buftype == 'neo-tree' then icon = 'פּ' end
  --     if vim.bo.buftype == 'toggleterm' then icon = ' ' end
  --     if vim.bo.buftype == 'minimap' then icon = '' end
  --     if vim.bo.buftype == 'octo' then icon = '' end
  --     if vim.bo.buftype == 'dap-repl' then icon = '' end
  --
  --     if icon == '' then return '' end
  --     return string.format(' %s', icon)
  --   end
  --
  --   -- M.section_filename = function(args)
  --   --   local sep = package.config:sub(1, 1)
  --   --
  --   --   ---Only append the path separator if the path is not empty
  --   --   ---@param path string
  --   --   ---@return string
  --   --   local function path_sep(path) return not mines.falsy(path) and path .. sep or path end
  --   --
  --   --   local curwin = vim.api.nvim_get_current_win()
  --   --   local curbuf = vim.api.nvim_win_get_buf(curwin)
  --   --
  --   --   local ctx = {
  --   --     bufnum = curbuf,
  --   --     win = curwin,
  --   --     bufname = vim.api.nvim_buf_get_name(curbuf),
  --   --     preview = vim.wo[curwin].previewwindow,
  --   --     readonly = vim.bo[curbuf].readonly,
  --   --     filetype = vim.bo[curbuf].ft,
  --   --     buftype = vim.bo[curbuf].bt,
  --   --     modified = vim.bo[curbuf].modified,
  --   --     fileformat = vim.bo[curbuf].fileformat,
  --   --     shiftwidth = vim.bo[curbuf].shiftwidth,
  --   --     expandtab = vim.bo[curbuf].expandtab,
  --   --   }
  --   --
  --   --   local buf, ft = ctx.bufnum, ctx.filetype
  --   --   local special_buf = special_buffers(ctx)
  --   --   if special_buf then return special_buf end
  --   --
  --   --   local path = vim.api.nvim_buf_get_name(buf)
  --   --   if mines.falsy(path) then return 'No Name' end
  --   --
  --   --   --- add ":." to the expansion i.e. to make the directory path relative to the current vim directory
  --   --   local parts = vim.split(vim.fn.fnamemodify(path, ':~'), sep)
  --   --   local fname = table.remove(parts)
  --   --
  --   --   local name = identifiers.names[ft]
  --   --   if name then return vim.is_callable(name) and name(fname, buf) or name end
  --   --
  --   --   local parent = table.remove(parts)
  --   --   fname = vim.fn.isdirectory(fname) == 1 and fname .. sep or fname
  --   --   if mines.falsy(parent) then return { fname = fname } end
  --   --
  --   --   local dir = path_sep(table.concat(parts, sep))
  --   --   if vim.api.nvim_strwidth(dir) > math.floor(vim.o.columns / 3) then dir = vim.fn.pathshorten(dir) end
  --   --
  --   --   -- return { dir = dir, parent = path_sep(parent), fname = fname }
  --   --   return { dir = dir, parent = path_sep(parent), fname = fname }
  --   -- end
  --   M.section_fileinfo = function(args)
  --     local filetype = vim.bo.filetype
  --
  --     -- Don't show anything if can't detect file type or not inside a "normal
  --     -- buffer"
  --     if (filetype == '') or H.isnt_normal_buffer() then return '' end
  --
  --     -- Construct output string if truncated
  --     if require('mini.statusline').is_truncated(args.trunc_width) then return filetype end
  --
  --     -- Construct output string with extra file info
  --     local encoding = vim.bo.fileencoding or vim.bo.encoding
  --     local format = vim.bo.fileformat
  --     local size = H.get_filesize()
  --
  --     return string.format('%s %s[%s] %s', filetype, encoding, format, size)
  --   end
  --   M.section_diagnostics = function(args)
  --     -- Assumption: there are no attached clients if table
  --     -- `vim.lsp.buf_get_clients()` is empty
  --     if H.diagnostic_levels == nil then
  --       H.diagnostic_levels = {
  --         {
  --           id = vim.diagnostic.severity.ERROR,
  --           sign = vim.fn.sign_getdefined('DiagnosticSignError')[1].text,
  --           hl = 'MiniStatuslineDiagnosticError',
  --         },
  --         {
  --           id = vim.diagnostic.severity.WARN,
  --           sign = vim.fn.sign_getdefined('DiagnosticSignWarn')[1].text,
  --           hl = 'MiniStatuslineDiagnosticWarn',
  --         },
  --         {
  --           id = vim.diagnostic.severity.INFO,
  --           sign = vim.fn.sign_getdefined('DiagnosticSignInfo')[1].text,
  --           hl = 'MiniStatuslineDiagnosticInfo',
  --         },
  --         {
  --           id = vim.diagnostic.severity.HINT,
  --           sign = vim.fn.sign_getdefined('DiagnosticSignHint')[1].text,
  --           hl = 'MiniStatsulineDiagnosticHint',
  --         },
  --       }
  --     end
  --     local hasnt_attached_client = next(vim.lsp.get_active_clients { bufnr = 0 }) == nil
  --     local dont_show_lsp = require('mini.statusline').is_truncated(args.trunc_width)
  --       or H.isnt_normal_buffer()
  --       or hasnt_attached_client
  --     if dont_show_lsp then return '' end
  --
  --     -- Construct diagnostic info using predefined order
  --     local t = {}
  --     for _, level in ipairs(H.diagnostic_levels) do
  --       local n = H.get_diagnostic_count(level.id)
  --       -- Add level info only if diagnostic is present
  --       if n > 0 then table.insert(t, H.hl(level.hl, string.format('%s%s', level.sign, n))) end
  --     end
  --
  --     if vim.tbl_count(t) == 0 then return '' end
  --     return string.format(' %s', table.concat(t, ''))
  --   end
  --   M.section_location = function(args)
  --     -- Use virtual column number to allow update when past last column
  --     if require('mini.statusline').is_truncated(args.trunc_width) then
  --       return H.hl('MiniStatuslineFileinfo', '%l:%v')
  --     end
  --
  --     if vim.o.buftype == 'terminal' or vim.o.buftype == 'quickfix' then return '' end
  --
  --     return table.concat(
  --       vim.tbl_map(function(component)
  --         if type(component) == 'string' then return H.hl('MiniStatuslineFileinfo', component) end
  --         return H.hl(component.hl, table.concat(component.strings, ''))
  --       end, {
  --         { hl = 'MiniStatuslineLocationRow', strings = { '%l' } },
  --         ':',
  --         { hl = 'MiniStatuslineLocationColumn', strings = { '%v' } },
  --         ' (',
  --         { hl = 'MiniStatuslineLocationPercentage', strings = { '%p' } },
  --         '%% %LL)',
  --       }),
  --       ''
  --     )
  --   end
  --
  --   function M.section_macro()
  --     local macro = vim.fn.reg_recording()
  --     if macro ~= '' then macro = string.format(' @%s ', macro) end
  --     return macro
  --   end
  --   function M.section_showcmd() return '%S ' end
  --   function M.section_luasnip(args)
  --     local has_luasnip, ls
  --     if luasnip_might_have_loaded then
  --       has_luasnip, ls = pcall(require, 'luasnip')
  --     else
  --       return ''
  --     end
  --     if require('mini.statusline').is_truncated(args.trunc_width) then return '' end
  --
  --     if vim.fn.mode() ~= 'i' then return '' end
  --
  --     local forward, backward, choice
  --     if has_luasnip and ls.expand_or_locally_jumpable() then
  --       forward = ls.jumpable(1) and '→' or ''
  --       backward = ls.jumpable(-1) and '←' or ''
  --       choice = ls.choice_active() and '?' or ''
  --       if #forward + #backward + #choice > 0 then return ' ' .. backward .. forward .. choice end
  --     end
  --     return ''
  --   end
  --   function M.section_wordcount()
  --     if
  --       vim.tbl_contains({
  --         'markdown',
  --         'org',
  --         'txt',
  --         'vimiwiki',
  --       }, vim.o.filetype)
  --     then
  --       return string.format('W%d ', vim.fn.wordcount().words)
  --     end
  --     return ''
  --   end
  --
  --   -- Override function used to make statusline:
  --   require('mini.statusline').combine_groups = function(groups)
  --     local parts = vim.tbl_map(function(s)
  --       if type(s) == 'string' then return s end
  --       if type(s) ~= 'table' then return '' end
  --
  --       local string_arr = vim.tbl_filter(function(x) return type(x) == 'string' and x ~= '' end, s.strings or {})
  --       local str = table.concat(string_arr, '')
  --
  --       -- Use previous highlight group
  --       if s.hl == nil then return ('%s'):format(str) end
  --
  --       -- Allow using this highlight group later
  --       if str:len() == 0 then return string.format('%%#%s#', s.hl) end
  --
  --       return string.format('%%#%s#%s', s.hl, str)
  --     end, groups)
  --
  --     return table.concat(parts, '')
  --   end
  --
  --   ----------------------------------------------------------------------------//
  --   -- Filename
  --   ----------------------------------------------------------------------------//
  --   local path = stl_file(ctx, plain)
  --
  --   -- Git
  --   --- @type {head: string?, added: integer?, changed: integer?, removed: integer?}
  --   local status = vim.b[curbuf].gitsigns_status_dict or {}
  --   local updates = vim.g.git_statusline_updates or {}
  --   local ahead = updates.ahead and tonumber(updates.ahead) or 0
  --   local behind = updates.behind and tonumber(updates.behind) or 0
  --
  --   require('mini.statusline').setup {
  --     content = {
  --       active = function()
  --         local mode, mode_hl = require('mini.statusline').section_mode { trunc_width = 120 }
  --
  --         local icon = M.section_icon { trunc_width = 75 }
  --         local fileinfo = M.section_fileinfo { trunc_width = 120 }
  --         local location = M.section_location { trunc_width = 75 }
  --         local diagnostics = M.section_diagnostics { trunc_width = 75 }
  --         local luasnip = M.section_luasnip { trunc_width = 75 }
  --         local macro = M.section_macro()
  --         local wordcount = M.section_wordcount()
  --
  --         return require('mini.statusline').combine_groups {
  --           '%<', -- Mark general truncate point
  --
  --           { hl = hls.indicator, strings = { icons.misc.block, ' ' } },
  --           { hl = mode_hl, strings = { mode } },
  --           -- { hl = mode_hl, strings = { ' ', filename, ' ' } },
  --           { hl = path.env.hl, strings = { ' ', path.env.item, '' } },
  --           { hl = path.dir.hl, strings = { '', path.dir.item, '' } },
  --           { hl = path.parent.hl, strings = { '', path.parent.item, '' } },
  --           { hl = path.file.hl, strings = { '', path.file.item, '' } },
  --           { hl = hls.modified, strings = { file_modified } },
  --
  --           { hl = 'MiniStatuslineLuaSnip', strings = { luasnip } },
  --           { hl = 'MiniStatuslineMacro', strings = { macro } },
  --           { hl = 'Statusline', strings = { '%=' } }, -- End left alignment
  --           { hl = 'MiniStatuslineWordcount', strings = { wordcount } },
  --           location,
  --           { hl = 'MiniStatuslineFileinfo', strings = { ' ', fileinfo, ' ' } },
  --           diagnostics,
  --         }
  --       end,
  --       inactive = function()
  --         -- local filename = M.section_filename { trunc_width = 140, inactive = true }
  --         return require('mini.statusline').combine_groups {
  --           { hl = 'StatuslineNC', strings = { ' ', path.env.item, '' } },
  --           { hl = 'StatuslineNC', strings = { '', path.dir.item, '' } },
  --           { hl = 'StatuslineNC', strings = { '', path.parent.item, '' } },
  --           { hl = 'StatuslineNC', strings = { '', path.file.item, '' } },
  --         }
  --       end,
  --     },
  --   }
  --
  --   mines.augroup('CustomStatusline', {
  --     event = 'FocusGained',
  --     command = function() vim.g.vim_in_focus = true end,
  --   }, {
  --     event = 'FocusLost',
  --     command = function() vim.g.vim_in_focus = false end,
  --   }, {
  --     event = 'ColorScheme',
  --     command = function() colors() end,
  --   })
  -- end,
}
